/* JawaScript - _РазноеProxy
Создайте функцию makeObservable(target), которая делает объект «наблюдаемым»,
 возвращая прокси.

 Решение состоит из двух частей:

1. При вызове .observe(handler) нам нужно где-то сохранить обработчик, чтобы вызвать его позже. 
    Можно хранить обработчики прямо в объекте, создав в нём для этого свой символьный ключ.
2. Нам нужен прокси с ловушкой set, чтобы вызывать обработчики при изменении свойств.
*/
'use strict';

alert("Start HW_makeObservable_РазноеProxy"); // ВАРІАНТ АВТОРА (із методом observe вих об'єкту і сховищем у вих об'єкті)

// Создаем ГЛОБАЛЬНУЮ символьную переменную, так как к ней обращаются и из исх об'ьекта, и из makeObservable
let handlers = Symbol('handlers');  // символьная переменная для создания символьного св-ва обь'екта

function makeObservable(target) {
  // 1. Создадим хранилище обработчиков в исходном обь'екте
  target[handlers] = [];  // создаем свойство исходного обь'екта и присваиваем ему пустой массив для хранения обработчиков

  //  в будущем положим туда функции-обработчики для вызовов

  // создаем метод observe исходного обь'екта (безьімянная ф-я, вьізьівается из глобальной области) для "пуширования" обработчиков в массив-свойство исходного обь'екта
  target.observe = function(handler) {
    this[handlers].push(handler);       // сохранение handler в массив-свойство исходного обь'екта
  };

  // 2. Создадим прокси для реакции на изменения
  return new Proxy(target, {
    set(target, property, value, receiver) {
      let success = Reflect.set(...arguments); // перенаправим операцию к оригинальному объекту - запись новой парьі свойство-значение
                                              // Reflect.set(...arguments) записывает свойство и возвращает в success: true при успехе, иначе false
      if (success) { // если не произошло ошибки при записи свойства (если true от Reflect.set)
        // вызовем обработчики
        target[handlers].forEach(handler => handler(property, value));  // вьізьіваются и вьіполняются обработчики для новой парьі свойство-значение
      }
      return success;  // фактчески  true  - return Reflect.set(...arguments) - инвариант ловушки
    }
  });
}

let user = {};

user = makeObservable(user);

// вьізьіваем метод об'ьекта (исходного, Reflect перенаправляет), которьій сохраняет обработчики в массив-свойство исходного обь'екта
// в аргумент метода помещаем желаемьій обработчик-стрелочную ф-ю - (key, value) => { alert(`SET ${key}=${value}`); }
user.observe((key, value) => {  // user.observe(handler) - вьізьіваем метод прокси => исходного обь'екта с handler в аргументе
  alert(`SET ${key}=${value}`);
});
user.observe((key, value) => {
  alert(`SET2 ${key}=${value}`);
});

user.name = "John"; // SET name=John       SET2 name=John
user.age = 38;      // SET age=38         SET2 age=38



alert("End");

