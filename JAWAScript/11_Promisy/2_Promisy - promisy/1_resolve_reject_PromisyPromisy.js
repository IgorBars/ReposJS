/* JawaScript - 1_resolve_reject_PromisyPromisy
Конструктор Promise и простой исполнитель с кодом, дающим результат с задержкой (через setTimeout):
*/
'use strict';
alert("Start 1_resolve_reject_PromisyPromisy");


let promise = new Promise(function(resolve, reject) {           // resolve, reject - зарегистрированньіе имена колбеков
  // функция function выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
// то есть resolve("done") означает, что в результате вьіполнения промиса в переменную promise запишется значение "done" 


/*
promise:    state: "pending"    result: undefined

  1. Функция-исполнитель запускается сразу же при вызове new Promise.

  2. Исполнитель получает два аргумента:    resolve и reject — это функции, встроенные в JavaScript, (!!!)
      поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал ОДНУ из них по готовности.

  Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат.

promise:      state: "fulfilled"     result: "done"
*/



//А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

let promise1 = new Promise(function(resolve, reject) {
  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});


// Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».
// Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
// Все последующие вызовы resolve и reject будут проигнорированы.

// Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть через какое-то время. 
// Но это не обязательно, resolve или reject могут быть вызваны сразу:

let promise2 = new Promise(function(resolve, reject) {
  // задача, не требующая времени
  resolve(123); // мгновенно выдаст результат: 123
});

// Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.
// Такая ситуация нормальна. Мы сразу получим успешно завершённый Promise.


alert("End");

