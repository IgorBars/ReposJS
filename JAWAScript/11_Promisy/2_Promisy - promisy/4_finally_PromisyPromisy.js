/* JawaScript - 4_finally_PromisyPromisy
                                                    Очистка: Обработчик finally
По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод-обработчик finally.
Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
*/
'use strict';

alert("Start 4_finally_PromisyPromisy");

let ind = 10;               // значение индикатора загрузки

new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
  setTimeout(() => resolve("value1"), 1000);

})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => ind = 0)   //остановить индикатор загрузки

  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => alert(result), err => alert(err))




// Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. 
//И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.

// Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.


new Promise((resolve, reject) => {
  setTimeout(() => resolve("value2"), 2000);
})
  .finally(() => alert("Промис2 завершён")) // срабатывает первым
  .then(result => alert(result)); // <-- .then показывает "value"


new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 3000);
  // throw new Error("error");
})
  .finally(() => alert("Промис3 завершён")) // срабатывает первым
  .catch(err => alert(err));  // <-- .catch показывает ошибку



// Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
// Если обработчик finally возвращает что-то, это игнорируется.
// Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.

alert("End");

